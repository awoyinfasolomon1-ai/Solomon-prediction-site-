  }
  localStorage.setItem('lastLevel', currentLevel);
  
  generateLevelButtons(); 

  // LOGIC: Auto-start the next level
  if (currentLevel <= maxLevel) {
      const message = unlockedNewLevel 
          ? ``New level unlocked! Level ${currentLevel} selected. Starting in 1 second...`
          : `Level ${currentLevel} selected. Starting in 1 second...`;
          
      statusDiv.textContent = message;
      document.getElementById('levelSelectionContainer').style.display = 'none'; 
      document.getElementById('game').style.display = 'grid'; 
      
      setTimeout(() => {
          startGame();
      }, 1000);
  } else {
      statusDiv.textContent = `You have beaten all ${maxLevel} levels, ${playerName}!`;
      // Return to level selection if all levels are beaten
      document.getElementById('game').style.display = 'none';
      document.getElementById('restartBtn').style.display = 'none';
      document.getElementById('levelSelectionContainer').style.display = 'block';
  }
}

// Restart current level
function restartLevel() {
  statusDiv.textContent = `Level ${currentLevel} restarted. Good luck, ${playerName}!`;
  setTimeout(startGame, 500);
}

// Make move (UI update)
function makeMove(row, col, player) {
  board[row][col] = player;
  const index = row * 3 + col;
  document.querySelector(`.cell[data-index='${index}']`).textContent = player;
}

/* --- AI Logic (Difficulty Scaling) --- */
function checkWin(bd, player) {
  for (let i = 0; i < 3; i++) {
    if (bd[i][0] === player && bd[i][1] === player && bd[i][2] === player) return true;
    if (bd[0][i] === player && bd[1][i] === player && bd[2][i] === player) return true;
  }
  if (bd[0][0] === player && bd[1][1] === player && bd[2][2] === player) return true;
  if (bd[0][2] === player && bd[1][1] === player && bd[2][0] === player) return true;
  return false;
}
function isBoardFull(bd) {
  return bd.flat().every(cell => cell !== '');
}
function getAvailableMoves(bd) {
  const moves = [];
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      if (bd[r][c] === '') {
        moves.push({row: r, col: c});
      }
    }
  }
  return moves;
}
function getRandomMove(bd) {
  const moves = getAvailableMoves(bd);
  if (moves.length === 0) return null;
  return moves[Math.floor(Math.random() * moves.length)];
}

function getAIMove(bd) {
    if (currentLevel >= 15) {
        return getBestMove(bd);
    } else if (currentLevel >= 5) {
        const minimaxChance = 0.5 + (currentLevel - 5) * 0.05; 
        if (Math.random() < minimaxChance) {
            return getBestMove(bd);
        } else {
            return getRandomMove(bd);
        }
    } else {
        return getRandomMove(bd);
    }
}

function getBestMove(bd) {
  let bestScore = -Infinity;
  let move = null;
  for (const m of getAvailableMoves(bd)) {
    bd[m.row][m.col] = ai;
    const score = minimax(bd, 0, false);
    bd[m.row][m.col] = '';
    if (score > bestScore) {
      bestScore = score;
      move = m;
    }
  }
  return move;
}
function minimax(bd, depth, isMax) {
  if (checkWin(bd, ai)) return 10 - depth;
  if (checkWin(bd, human)) return depth - 10;
  if (isBoardFull(bd)) return 0;
  if (isMax) {
    let maxEval = -Infinity;
    for (const m of getAvailableMoves(bd)) {
      bd[m.row][m.col] = ai;
      const evalScore = minmax(bd, depth + 1, false);
      bd[m.row][m.col] = ''; 
      maxEval = Math.max(maxEval, evalScore);
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for (const m of getAvailableMoves(bd)) {
      bd[m.row][m.col] = human;
      const evalScore = minmax(bd, depth + 1, true);
      bd[m.row][m.col] = '';
      minEval = Math.min(minEval, evalScore);
    }
    return minEval;
  }
}
// Re-call generateLevelButtons if the page is loaded with a stored name
if(playerName) {
    generateLevelButtons();
}
</script>

</body>
</html>
  }
  localStorage.setItem('lastLevel', currentLevel);
  
  generateLevelButtons(); 

  // LOGIC: Auto-start the next level
  if (currentLevel <= maxLevel) {
      const message = unlockedNewLevel 
          ? ``New level unlocked! Level ${currentLevel} selected. Starting in 1 second...`
          : `Level ${currentLevel} selected. Starting in 1 second...`;
          
      statusDiv.textContent = message;
      document.getElementById('levelSelectionContainer').style.display = 'none'; 
      document.getElementById('game').style.display = 'grid'; 
      
      setTimeout(() => {
          startGame();
      }, 1000);
  } else {
      statusDiv.textContent = `You have beaten all ${maxLevel} levels, ${playerName}!`;
      // Return to level selection if all levels are beaten
      document.getElementById('game').style.display = 'none';
      document.getElementById('restartBtn').style.display = 'none';
      document.getElementById('levelSelectionContainer').style.display = 'block';
  }
}

// Restart current level
function restartLevel() {
  statusDiv.textContent = `Level ${currentLevel} restarted. Good luck, ${playerName}!`;
  setTimeout(startGame, 500);
}

// Make move (UI update)
function makeMove(row, col, player) {
  board[row][col] = player;
  const index = row * 3 + col;
  document.querySelector(`.cell[data-index='${index}']`).textContent = player;
}

/* --- AI Logic (Difficulty Scaling) --- */
function checkWin(bd, player) {
  for (let i = 0; i < 3; i++) {
    if (bd[i][0] === player && bd[i][1] === player && bd[i][2] === player) return true;
    if (bd[0][i] === player && bd[1][i] === player && bd[2][i] === player) return true;
  }
  if (bd[0][0] === player && bd[1][1] === player && bd[2][2] === player) return true;
  if (bd[0][2] === player && bd[1][1] === player && bd[2][0] === player) return true;
  return false;
}
function isBoardFull(bd) {
  return bd.flat().every(cell => cell !== '');
}
function getAvailableMoves(bd) {
  const moves = [];
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      if (bd[r][c] === '') {
        moves.push({row: r, col: c});
      }
    }
  }
  return moves;
}
function getRandomMove(bd) {
  const moves = getAvailableMoves(bd);
  if (moves.length === 0) return null;
  return moves[Math.floor(Math.random() * moves.length)];
}

function getAIMove(bd) {
    if (currentLevel >= 15) {
        return getBestMove(bd);
    } else if (currentLevel >= 5) {
        const minimaxChance = 0.5 + (currentLevel - 5) * 0.05; 
        if (Math.random() < minimaxChance) {
            return getBestMove(bd);
        } else {
            return getRandomMove(bd);
        }
    } else {
        return getRandomMove(bd);
    }
}

function getBestMove(bd) {
  let bestScore = -Infinity;
  let move = null;
  for (const m of getAvailableMoves(bd)) {
    bd[m.row][m.col] = ai;
    const score = minimax(bd, 0, false);
    bd[m.row][m.col] = '';
    if (score > bestScore) {
      bestScore = score;
      move = m;
    }
  }
  return move;
}
function minimax(bd, depth, isMax) {
  if (checkWin(bd, ai)) return 10 - depth;
  if (checkWin(bd, human)) return depth - 10;
  if (isBoardFull(bd)) return 0;
  if (isMax) {
    let maxEval = -Infinity;
    for (const m of getAvailableMoves(bd)) {
      bd[m.row][m.col] = ai;
      const evalScore = minmax(bd, depth + 1, false);
      bd[m.row][m.col] = ''; 
      maxEval = Math.max(maxEval, evalScore);
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for (const m of getAvailableMoves(bd)) {
      bd[m.row][m.col] = human;
      const evalScore = minmax(bd, depth + 1, true);
      bd[m.row][m.col] = '';
      minEval = Math.min(minEval, evalScore);
    }
    return minEval;
  }
}
// Re-call generateLevelButtons if the page is loaded with a stored name
if(playerName) {
    generateLevelButtons();
}
</script>

</body>
</html> 
